---
title: LeetCode 201-Bitwise AND of Numbers Range
date: 2017-12-08 14:06:50
toc: true
categories: 
- 算法
tags:
- LeetCode
---
# 分析
如果真的在范围[m, n]内按顺序逐个数字做&操作显然效率不高。那么我们可以先列出一些数字去寻找规律：

12  1100  110  11
13  1101  110  11
14  1110  111  11
15  1111  111  11

上表区间中在移位过程中，逐渐抹去最后一位，最终会在某一次移位后区间内所有数的值相同（1101->110->11），移位次数为2，该范围内所有数按位与操作以后结果为1100，即12。由此我们可以知道，低位部分在范围内按位与操作中会因为0的存在而消去为0，只有高位部分会得以保留。因此我们可以用一个count计数器记录移位次数（即低位0的个数），而最终移位结果均一致时（如例子中最终为二进制11），即为其高位部分。此时只需将高位部分复原即可，也就是11->110->1100，做2次向左移位复原。
当然在计算过程中我们并不需要对区间内所有数做这种操作，**只需对区间最小值m和最大值n进行操作**（因为区间首尾是区分度最大的两个数，对区间内所有数做右移时，最有可能不相同的肯定是m和n）。
# 注意
**当较小的数移位后为0时，就应该停止循环**。最终结果肯定也是0。

```cpp
class Solution {
public:
    int rangeBitwiseAnd(int m, int n) {
        int count = 0;//初始化计数器
        while (m && m != n) {//m为0时或m == n时退出循环
            ++count;//统计低位0的个数
            m >>= 1; n >>= 1;//抹去低位
        }
        return m << count;//低位复原, 因为0 << count仍为0, 因此此处不做区分
    }
};
```